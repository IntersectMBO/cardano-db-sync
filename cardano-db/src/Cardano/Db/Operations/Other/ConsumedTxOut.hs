{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Cardano.Db.Operations.Other.ConsumedTxOut where

-- import Cardano.BM.Trace (Trace, logInfo)
-- import Cardano.Db.Error (LookupFail (..), logAndThrowIO)
-- import Cardano.Db.Operations.Insert (insertExtraMigration)
-- import Cardano.Db.Operations.Query (listToMaybe, queryAllExtraMigrations, queryBlockHeight, queryBlockNo, queryMaxRefId)
-- import Cardano.Db.Operations.QueryHelper (isJust)
-- import Cardano.Db.Operations.Types (TxOutFields (..), TxOutIdW (..), TxOutTable, TxOutVariantType (..), isTxOutVariantAddress)
-- import Cardano.Db.Schema.Core
-- import qualified Cardano.Db.Schema.Variants.TxOutAddress as V
-- import qualified Cardano.Db.Schema.Variants.TxOutCore as C
-- import Cardano.Db.Types (ExtraMigration (..), MigrationValues (..), PruneConsumeMigration (..), processMigrationValues)
-- import Cardano.Prelude (textShow, void)
-- import Control.Exception (throw)
-- import Control.Exception.Lifted (handle, throwIO)
-- import Control.Monad.Extra (unless, when, whenJust)
-- import Control.Monad.IO.Class (MonadIO, liftIO)
-- import Control.Monad.Trans.Control (MonadBaseControl)
-- import Control.Monad.Trans.Reader (ReaderT)
-- import Data.Int (Int64)
-- import Data.Text (Text)
-- import qualified Data.Text as Text
-- import Data.Word (Word64)
-- import Database.Esqueleto.Experimental hiding (update, (<=.), (=.), (==.))
-- import qualified Database.Esqueleto.Experimental as E
-- import Database.Persist ((<=.), (=.), (==.))
-- import Database.Persist.Class (update)
-- import Database.Persist.Sql (deleteWhereCount)
-- import Database.PostgreSQL.Simple (SqlError)

-- pageSize :: Word64
-- pageSize = 100_000

-- data ConsumedTriplet = ConsumedTriplet
--   { ctTxOutTxId :: TxId -- The txId of the txOut
--   , ctTxOutIndex :: Word64 -- Tx index of the txOut
--   , ctTxInTxId :: TxId -- The txId of the txId
--   }

-- --------------------------------------------------------------------------------------------------
-- -- Queries
-- --------------------------------------------------------------------------------------------------
-- querySetNullTxOut ::
--   MonadIO m =>
--   TxOutVariantType ->
--   Maybe TxId ->
--   DB.DbAction m (Text, Int64)
-- querySetNullTxOut txOutVariantType mMinTxId = do
--   case mMinTxId of
--     Nothing -> do
--       pure ("No tx_out to set to null", 0)
--     Just txId -> do
--       txOutIds <- getTxOutConsumedAfter txId
--       mapM_ setNullTxOutConsumedAfter txOutIds
--       let updatedEntriesCount = length txOutIds
--       pure ("tx_out.consumed_by_tx_id", fromIntegral updatedEntriesCount)
--   where
--     -- \| This requires an index at TxOutConsumedByTxId.
--     getTxOutConsumedAfter :: MonadIO m => TxId -> DB.DbAction m [TxOutIdW]
--     getTxOutConsumedAfter txId =
--       case txOutVariantType of
--         TxOutVariantCore -> wrapTxOutIds VCTxOutIdW (queryConsumedTxOutIds @'TxOutCore txId)
--         TxOutVariantAddress -> wrapTxOutIds VATxOutIdW (queryConsumedTxOutIds @'TxOutVariantAddress txId)
--       where
--         wrapTxOutIds constructor = fmap (map constructor)

--         queryConsumedTxOutIds ::
--           forall a m.
--           (TxOutFields a, MonadIO m) =>
--           TxId ->
--           DB.DbAction m [TxOutIdFor a]
--         queryConsumedTxOutIds txId' = do
--           res <- select $ do
--             txOut <- from $ table @(TxOutTable a)
--             where_ (txOut ^. txOutConsumedByTxIdField @a >=. just (val txId'))
--             pure $ txOut ^. txOutIdField @a
--           pure $ map unValue res

--     -- \| This requires an index at TxOutConsumedByTxId.
--     setNullTxOutConsumedAfter :: MonadIO m => TxOutIdW -> DB.DbAction m ()
--     setNullTxOutConsumedAfter txOutId =
--       case txOutVariantType of
--         TxOutVariantCore -> setNull
--         TxOutVariantAddress -> setNull
--       where
--         setNull ::
--           MonadIO m =>
--           DB.DbAction m ()
--         setNull = do
--           case txOutId of
--             VCTxOutIdW txOutId' -> update txOutId' [C.TxOutConsumedByTxId =. Nothing]
--             VATxOutIdW txOutId' -> update txOutId' [V.TxOutConsumedByTxId =. Nothing]

-- runConsumedTxOutMigrations :: MonadIO m => Trace IO Text -> TxOutVariantType -> Word64 -> PruneConsumeMigration -> DB.DbAction m ()
-- runConsumedTxOutMigrations trce txOutVariantType blockNoDiff pcm = do
--   ems <- queryAllExtraMigrations
--   isTxOutNull <- queryTxOutIsNull txOutVariantType
--   let migrationValues = processMigrationValues ems pcm
--       isTxOutVariant = isTxOutVariantAddress txOutVariantType
--       isTxOutAddressSet = isTxOutAddressPreviouslySet migrationValues

--   -- can only run "use_address_table" on a non populated database but don't throw if the migration was previously set
--   when (isTxOutVariant && not isTxOutNull && not isTxOutAddressSet) $
--     throw $
--       DBExtraMigration "runConsumedTxOutMigrations: The use of the config 'tx_out.use_address_table' can only be caried out on a non populated database."
--   -- Make sure the config "use_address_table" is there if the migration wasn't previously set in the past
--   when (not isTxOutVariant && isTxOutAddressSet) $
--     throw $
--       DBExtraMigration "runConsumedTxOutMigrations: The configuration option 'tx_out.use_address_table' was previously set and the database updated. Unfortunately reverting this isn't possible."
--   -- Has the user given txout address config && the migration wasn't previously set
--   when (isTxOutVariant && not isTxOutAddressSet) $ do
--     updateTxOutAndCreateAddress trce
--     insertExtraMigration TxOutAddressPreviouslySet
--   -- first check if pruneTxOut flag is missing and it has previously been used
--   when (isPruneTxOutPreviouslySet migrationValues && not (pcmPruneTxOut pcm)) $
--     throw $
--       DBExtraMigration
--         "If --prune-tx-out flag is enabled and then db-sync is stopped all future executions of db-sync should still have this flag activated. Otherwise, it is considered bad usage and can cause crashes."
--   handleMigration migrationValues
--   where
--     handleMigration :: MonadIO m => MigrationValues -> DB.DbAction m ()
--     handleMigration migrationValues@MigrationValues {..} = do
--       let PruneConsumeMigration {..} = pruneConsumeMigration
--       case (isConsumeTxOutPreviouslySet, pcmConsumedTxOut, pcmPruneTxOut) of
--         -- No Migration Needed
--         (False, False, False) -> do
--           liftIO $ logInfo trce "runConsumedTxOutMigrations: No extra migration specified"
--         -- Already migrated
--         (True, True, False) -> do
--           liftIO $ logInfo trce "runConsumedTxOutMigrations: Extra migration consumed_tx_out already executed"
--         -- Invalid State
--         (True, False, False) -> liftIO $ logAndThrowIO trce "runConsumedTxOutMigrations: consumed-tx-out or prune-tx-out is not set, but consumed migration is found."
--         -- Consume TxOut
--         (False, True, False) -> do
--           liftIO $ logInfo trce "runConsumedTxOutMigrations: Running extra migration consumed_tx_out"
--           insertExtraMigration ConsumeTxOutPreviouslySet
--           migrateTxOut trce txOutVariantType $ Just migrationValues
--         -- Prune TxOut
--         (_, _, True) -> do
--           unless isPruneTxOutPreviouslySet $ insertExtraMigration PruneTxOutFlagPreviouslySet
--           if isConsumeTxOutPreviouslySet
--             then do
--               liftIO $ logInfo trce "runConsumedTxOutMigrations: Running extra migration prune tx_out"
--               deleteConsumedTxOut trce txOutVariantType blockNoDiff
--             else deleteAndUpdateConsumedTxOut trce txOutVariantType migrationValues blockNoDiff

-- queryWrongConsumedBy :: TxOutVariantType -> MonadIO m => DB.DbAction m Word64
-- queryWrongConsumedBy = \case
--   TxOutVariantCore -> query @'TxOutCore
--   TxOutVariantAddress -> query @'TxOutVariantAddress
--   where
--     query ::
--       forall (a :: TxOutVariantType) m.
--       (MonadIO m, TxOutFields a) =>
--       DB.DbAction m Word64
--     query = do
--       res <- select $ do
--         txOut <- from $ table @(TxOutTable a)
--         where_ (just (txOut ^. txOutTxIdField @a) E.==. txOut ^. txOutConsumedByTxIdField @a)
--         pure countRows
--       pure $ maybe 0 unValue (listToMaybe res)

-- --------------------------------------------------------------------------------------------------
-- -- Queries Tests
-- --------------------------------------------------------------------------------------------------

-- -- | This is a count of the null consumed_by_tx_id
-- queryTxOutConsumedNullCount :: TxOutVariantType -> MonadIO m => DB.DbAction m Word64
-- queryTxOutConsumedNullCount = \case
--   TxOutVariantCore -> query @'TxOutCore
--   TxOutVariantAddress -> query @'TxOutVariantAddress
--   where
--     query ::
--       forall (a :: TxOutVariantType) m.
--       (MonadIO m, TxOutFields a) =>
--       DB.DbAction m Word64
--     query = do
--       res <- select $ do
--         txOut <- from $ table @(TxOutTable a)
--         where_ (isNothing $ txOut ^. txOutConsumedByTxIdField @a)
--         pure countRows
--       pure $ maybe 0 unValue (listToMaybe res)

-- queryTxOutConsumedCount :: TxOutVariantType -> MonadIO m => DB.DbAction m Word64
-- queryTxOutConsumedCount = \case
--   TxOutVariantCore -> query @'TxOutCore
--   TxOutVariantAddress -> query @'TxOutVariantAddress
--   where
--     query ::
--       forall (a :: TxOutVariantType) m.
--       (MonadIO m, TxOutFields a) =>
--       DB.DbAction m Word64
--     query = do
--       res <- select $ do
--         txOut <- from $ table @(TxOutTable a)
--         where_ (not_ $ isNothing $ txOut ^. txOutConsumedByTxIdField @a)
--         pure countRows
--       pure $ maybe 0 unValue (listToMaybe res)

-- queryTxOutIsNull :: TxOutVariantType -> MonadIO m => DB.DbAction m Bool
-- queryTxOutIsNull = \case
--   TxOutVariantCore -> pure False
--   TxOutVariantAddress -> query @'TxOutVariantAddress
--   where
--     query ::
--       forall (a :: TxOutVariantType) m.
--       (MonadIO m, TxOutFields a) =>
--       DB.DbAction m Bool
--     query = do
--       res <- select $ do
--         _ <- from $ table @(TxOutTable a)
--         limit 1
--         pure (val (1 :: Int))
--       pure $ null res

-- --------------------------------------------------------------------------------------------------
-- -- Updates
-- --------------------------------------------------------------------------------------------------
-- updateListTxOutConsumedByTxId :: MonadIO m => [(TxOutIdW, TxId)] -> DB.DbAction m ()
-- updateListTxOutConsumedByTxId ls = do
--   mapM_ (uncurry updateTxOutConsumedByTxId) ls
--   where
--     updateTxOutConsumedByTxId :: MonadIO m => TxOutIdW -> TxId -> DB.DbAction m ()
--     updateTxOutConsumedByTxId txOutId txId =
--       case txOutId of
--         VCTxOutIdW txOutId' -> update txOutId' [C.TxOutConsumedByTxId =. Just txId]
--         VATxOutIdW txOutId' -> update txOutId' [V.TxOutConsumedByTxId =. Just txId]

-- migrateTxOut ::
--   ( MonadBaseControl IO m
--   , MonadIO m
--   ) =>
--   Trace IO Text ->
--   TxOutVariantType ->
--   Maybe MigrationValues ->
--   DB.DbAction m ()
-- migrateTxOut trce txOutVariantType mMvs = do
--   whenJust mMvs $ \mvs -> do
--     when (pcmConsumedTxOut (pruneConsumeMigration mvs) && not (isTxOutAddressPreviouslySet mvs)) $ do
--       liftIO $ logInfo trce "migrateTxOut: adding consumed-by-id Index"
--       void createConsumedIndexTxOut
--     when (pcmPruneTxOut (pruneConsumeMigration mvs)) $ do
--       liftIO $ logInfo trce "migrateTxOut: adding prune contraint on tx_out table"
--       void createPruneConstraintTxOut
--   migrateNextPageTxOut (Just trce) txOutVariantType 0

-- migrateNextPageTxOut :: MonadIO m => Maybe (Trace IO Text) -> TxOutVariantType -> Word64 -> DB.DbAction m ()
-- migrateNextPageTxOut mTrce txOutVariantType offst = do
--   whenJust mTrce $ \trce ->
--     liftIO $ logInfo trce $ "migrateNextPageTxOut: Handling input offset " <> textShow offst
--   page <- getInputPage offst pageSize
--   updatePageEntries txOutVariantType page
--   when (fromIntegral (length page) == pageSize) $
--     migrateNextPageTxOut mTrce txOutVariantType $!
--       (offst + pageSize)

-- --------------------------------------------------------------------------------------------------
-- -- Delete + Update
-- -- --------------------------------------------------------------------------------------------------
-- deleteAndUpdateConsumedTxOut ::
--   forall m.
--   (MonadIO m, MonadBaseControl IO m) =>
--   Trace IO Text ->
--   TxOutVariantType ->
--   MigrationValues ->
--   Word64 ->
--   DB.DbAction m ()
-- deleteAndUpdateConsumedTxOut trce txOutVariantType migrationValues blockNoDiff = do
--   maxTxId <- findMaxTxInId blockNoDiff
--   case maxTxId of
--     Left errMsg -> do
--       liftIO $ logInfo trce $ "No tx_out were deleted as no blocks found: " <> errMsg
--       liftIO $ logInfo trce "deleteAndUpdateConsumedTxOut: Now Running extra migration prune tx_out"
--       migrateTxOut trce txOutVariantType $ Just migrationValues
--       insertExtraMigration ConsumeTxOutPreviouslySet
--     Right mTxId -> do
--       migrateNextPage mTxId False 0
--   where
--     migrateNextPage :: TxId -> Bool -> Word64 -> DB.DbAction m ()
--     migrateNextPage maxTxId ranCreateConsumedTxOut offst = do
--       pageEntries <- getInputPage offst pageSize
--       resPageEntries <- splitAndProcessPageEntries trce txOutVariantType ranCreateConsumedTxOut maxTxId pageEntries
--       when (fromIntegral (length pageEntries) == pageSize) $
--         migrateNextPage maxTxId resPageEntries $!
--           offst
--             + pageSize

-- -- Split the page entries by maxTxInId and process
-- splitAndProcessPageEntries ::
--   forall m.
--   (MonadIO m, MonadBaseControl IO m) =>
--   Trace IO Text ->
--   TxOutVariantType ->
--   Bool ->
--   TxId ->
--   [ConsumedTriplet] ->
--   DB.DbAction m Bool
-- splitAndProcessPageEntries trce txOutVariantType ranCreateConsumedTxOut maxTxId pageEntries = do
--   let entriesSplit = span (\tr -> ctTxInTxId tr <= maxTxId) pageEntries
--   case entriesSplit of
--     ([], []) -> do
--       shouldCreateConsumedTxOut trce ranCreateConsumedTxOut
--       pure True
--     -- the whole list is less that maxTxInId
--     (xs, []) -> do
--       deletePageEntries txOutVariantType xs
--       pure False
--     -- the whole list is greater that maxTxInId
--     ([], ys) -> do
--       shouldCreateConsumedTxOut trce ranCreateConsumedTxOut
--       updatePageEntries txOutVariantType ys
--       pure True
--     -- the list has both bellow and above maxTxInId
--     (xs, ys) -> do
--       deletePageEntries txOutVariantType xs
--       shouldCreateConsumedTxOut trce ranCreateConsumedTxOut
--       updatePageEntries txOutVariantType ys
--       pure True

-- shouldCreateConsumedTxOut ::
--   (MonadIO m, MonadBaseControl IO m) =>
--   Trace IO Text ->
--   Bool ->
--   DB.DbAction m ()
-- shouldCreateConsumedTxOut trce rcc =
--   unless rcc $ do
--     liftIO $ logInfo trce "Created ConsumedTxOut when handling page entries."
--     createConsumedIndexTxOut

-- -- | Update
-- updatePageEntries ::
--   MonadIO m =>
--   TxOutVariantType ->
--   [ConsumedTriplet] ->
--   DB.DbAction m ()
-- updatePageEntries txOutVariantType = mapM_ (updateTxOutConsumedByTxIdUnique txOutVariantType)

-- updateTxOutConsumedByTxIdUnique :: MonadIO m => TxOutVariantType -> ConsumedTriplet -> DB.DbAction m ()
-- updateTxOutConsumedByTxIdUnique txOutVariantType ConsumedTriplet {ctTxOutTxId, ctTxOutIndex, ctTxInTxId} =
--   case txOutVariantType of
--     TxOutVariantCore -> updateWhere [C.TxOutTxId ==. ctTxOutTxId, C.TxOutIndex ==. ctTxOutIndex] [C.TxOutConsumedByTxId =. Just ctTxInTxId]
--     TxOutVariantAddress -> updateWhere [V.TxOutTxId ==. ctTxOutTxId, V.TxOutIndex ==. ctTxOutIndex] [V.TxOutConsumedByTxId =. Just ctTxInTxId]

-- -- -- this builds up a single delete query using the pageEntries list
-- deletePageEntries ::
--   MonadIO m =>
--   TxOutVariantType ->
--   [ConsumedTriplet] ->
--   DB.DbAction m ()
-- deletePageEntries txOutVariantType = mapM_ (\ConsumedTriplet {ctTxOutTxId, ctTxOutIndex} -> deleteTxOutConsumed txOutVariantType ctTxOutTxId ctTxOutIndex)

-- deleteTxOutConsumed :: MonadIO m => TxOutVariantType -> TxId -> Word64 -> DB.DbAction m ()
-- deleteTxOutConsumed txOutVariantType txOutId index = case txOutVariantType of
--   TxOutVariantCore -> deleteWhere [C.TxOutTxId ==. txOutId, C.TxOutIndex ==. index]
--   TxOutVariantAddress -> deleteWhere [V.TxOutTxId ==. txOutId, V.TxOutIndex ==. index]

-- --------------------------------------------------------------------------------------------------
-- -- Raw Queries
-- --------------------------------------------------------------------------------------------------

-- createConsumedIndexTxOut ::
--   forall m.
--   ( MonadBaseControl IO m
--   , MonadIO m
--   ) =>
--   DB.DbAction m ()
-- createConsumedIndexTxOut = do
--   handle exceptHandler $ rawExecute createIndex []
--   where
--     createIndex =
--       "CREATE INDEX IF NOT EXISTS idx_tx_out_consumed_by_tx_id ON tx_out (consumed_by_tx_id)"

--     exceptHandler :: SqlError -> DB.DbAction m a
--     exceptHandler e =
--       liftIO $ throwIO (DBPruneConsumed $ show e)

-- createPruneConstraintTxOut ::
--   forall m.
--   ( MonadBaseControl IO m
--   , MonadIO m
--   ) =>
--   DB.DbAction m ()
-- createPruneConstraintTxOut = do
--   handle exceptHandler $ rawExecute addConstraint []
--   where
--     addConstraint =
--       Text.unlines
--         [ "do $$"
--         , "begin"
--         , "  if not exists ("
--         , "    select 1"
--         , "    from information_schema.table_constraints"
--         , "    where constraint_name = 'ma_tx_out_tx_out_id_fkey'"
--         , "      and table_name = 'ma_tx_out'"
--         , "  ) then"
--         , "    execute 'alter table ma_tx_out add constraint ma_tx_out_tx_out_id_fkey foreign key(tx_out_id) references tx_out(id) on delete cascade on update restrict';"
--         , "  end if;"
--         , "end $$;"
--         ]

--     exceptHandler :: SqlError -> DB.DbAction m a
--     exceptHandler e =
--       liftIO $ throwIO (DBPruneConsumed $ show e)

-- -- Be very mindfull that these queries can fail silently and make tests fail making it hard to know why.
-- -- To help mitigate this, logs are printed after each query is ran, so one can know where it stopped.
-- updateTxOutAndCreateAddress ::
--   forall m.
--   ( MonadBaseControl IO m
--   , MonadIO m
--   ) =>
--   Trace IO Text ->
--   DB.DbAction m ()
-- updateTxOutAndCreateAddress trc = do
--   handle exceptHandler $ rawExecute dropViewsQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Dropped views"
--   handle exceptHandler $ rawExecute alterTxOutQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Altered tx_out"
--   handle exceptHandler $ rawExecute alterCollateralTxOutQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Altered collateral_tx_out"
--   handle exceptHandler $ rawExecute createAddressTableQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Created address table"
--   handle exceptHandler $ rawExecute createIndexPaymentCredQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Created index payment_cred"
--   handle exceptHandler $ rawExecute createIndexRawQuery []
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Created index raw"
--   liftIO $ logInfo trc "updateTxOutAndCreateAddress: Completed"
--   where
--     dropViewsQuery =
--       Text.unlines
--         [ "DROP VIEW IF EXISTS utxo_byron_view;"
--         , "DROP VIEW IF EXISTS utxo_view;"
--         ]

--     alterTxOutQuery =
--       Text.unlines
--         [ "ALTER TABLE \"tx_out\""
--         , "  ADD COLUMN \"address_id\" INT8 NOT NULL,"
--         , "  DROP COLUMN \"address\","
--         , "  DROP COLUMN \"address_has_script\","
--         , "  DROP COLUMN \"payment_cred\""
--         ]

--     alterCollateralTxOutQuery =
--       Text.unlines
--         [ "ALTER TABLE \"collateral_tx_out\""
--         , "  ADD COLUMN \"address_id\" INT8 NOT NULL,"
--         , "  DROP COLUMN \"address\","
--         , "  DROP COLUMN \"address_has_script\","
--         , "  DROP COLUMN \"payment_cred\""
--         ]

--     createAddressTableQuery =
--       Text.unlines
--         [ "CREATE TABLE \"address\" ("
--         , "  \"id\" SERIAL8 PRIMARY KEY UNIQUE,"
--         , "  \"address\" VARCHAR NOT NULL,"
--         , "  \"raw\" BYTEA NOT NULL,"
--         , "  \"has_script\" BOOLEAN NOT NULL,"
--         , "  \"payment_cred\" hash28type NULL,"
--         , "  \"stake_address_id\" INT8 NULL"
--         , ")"
--         ]

--     createIndexPaymentCredQuery =
--       "CREATE INDEX IF NOT EXISTS idx_address_payment_cred ON address(payment_cred);"

--     createIndexRawQuery =
--       "CREATE INDEX IF NOT EXISTS idx_address_raw ON address USING HASH (raw);"

--     exceptHandler :: SqlError -> DB.DbAction m a
--     exceptHandler e =
--       liftIO $ throwIO (DBPruneConsumed $ show e)

-- --------------------------------------------------------------------------------------------------
-- -- Delete
-- --------------------------------------------------------------------------------------------------
-- deleteConsumedTxOut ::
--   forall m.
--   MonadIO m =>
--   Trace IO Text ->
--   TxOutVariantType ->
--   Word64 ->
--   DB.DbAction m ()
-- deleteConsumedTxOut trce txOutVariantType blockNoDiff = do
--   maxTxInId <- findMaxTxInId blockNoDiff
--   case maxTxInId of
--     Left errMsg -> liftIO $ logInfo trce $ "No tx_out was deleted: " <> errMsg
--     Right mxtid -> deleteConsumedBeforeTx trce txOutVariantType mxtid

-- deleteConsumedBeforeTx :: MonadIO m => Trace IO Text -> TxOutVariantType -> TxId -> DB.DbAction m ()
-- deleteConsumedBeforeTx trce txOutVariantType txId = do
--   countDeleted <- case txOutVariantType of
--     TxOutVariantCore -> deleteWhereCount [C.TxOutConsumedByTxId <=. Just txId]
--     TxOutVariantAddress -> deleteWhereCount [V.TxOutConsumedByTxId <=. Just txId]
--   liftIO $ logInfo trce $ "Deleted " <> textShow countDeleted <> " tx_out"

-- --------------------------------------------------------------------------------------------------
-- -- Helpers
-- --------------------------------------------------------------------------------------------------
-- migrateTxOutDbTool :: (MonadIO m, MonadBaseControl IO m) => TxOutVariantType -> DB.DbAction m ()
-- migrateTxOutDbTool txOutVariantType = do
--   _ <- createConsumedIndexTxOut
--   migrateNextPageTxOut Nothing txOutVariantType 0

-- findMaxTxInId :: forall m. MonadIO m => Word64 -> DB.DbAction m (Either Text TxId)
-- findMaxTxInId blockNoDiff = do
--   mBlockHeight <- queryBlockHeight
--   maybe (pure $ Left "No blocks found") findConsumed mBlockHeight
--   where
--     findConsumed :: Word64 -> DB.DbAction m (Either Text TxId)
--     findConsumed tipBlockNo = do
--       if tipBlockNo <= blockNoDiff
--         then pure $ Left $ "Tip blockNo is " <> textShow tipBlockNo
--         else do
--           mBlockId <- queryBlockNo $ tipBlockNo - blockNoDiff
--           maybe
--             (pure $ Left $ "BlockNo hole found at " <> textShow (tipBlockNo - blockNoDiff))
--             findConsumedBeforeBlock
--             mBlockId

--     findConsumedBeforeBlock :: BlockId -> DB.DbAction m (Either Text TxId)
--     findConsumedBeforeBlock blockId = do
--       mTxId <- queryMaxRefId TxBlockId blockId False
--       case mTxId of
--         Nothing -> pure $ Left $ "No txs found before " <> textShow blockId
--         Just txId -> pure $ Right txId

-- getInputPage :: MonadIO m => Word64 -> Word64 -> DB.DbAction m [ConsumedTriplet]
-- getInputPage offs pgSize = do
--   res <- select $ do
--     txIn <- from $ table @TxIn
--     limit (fromIntegral pgSize)
--     offset (fromIntegral offs)
--     orderBy [asc (txIn ^. TxInId)]
--     pure txIn
--   pure $ convert <$> res
--   where
--     convert txIn =
--       ConsumedTriplet
--         { ctTxOutTxId = txInTxOutId (entityVal txIn)
--         , ctTxOutIndex = txInTxOutIndex (entityVal txIn)
--         , ctTxInTxId = txInTxInId (entityVal txIn)
--         }

-- countTxIn :: MonadIO m => DB.DbAction m Word64
-- countTxIn = do
--   res <- select $ do
--     _ <- from $ table @TxIn
--     pure countRows
--   pure $ maybe 0 unValue (listToMaybe res)

-- countConsumed ::
--   MonadIO m =>
--   TxOutVariantType ->
--   DB.DbAction m Word64
-- countConsumed = \case
--   TxOutVariantCore -> query @'TxOutCore
--   TxOutVariantAddress -> query @'TxOutVariantAddress
--   where
--     query ::
--       forall (a :: TxOutVariantType) m.
--       (MonadIO m, TxOutFields a) =>
--       DB.DbAction m Word64
--     query = do
--       res <- select $ do
--         txOut <- from $ table @(TxOutTable a)
--         where_ (isJust $ txOut ^. txOutConsumedByTxIdField @a)
--         pure countRows
--       pure $ maybe 0 unValue (listToMaybe res)
