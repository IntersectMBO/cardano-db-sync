{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE NoImplicitPrelude #-}

module Cardano.DbSync.Error (
  annotateInvariantTx,
  dbSyncInvariant,
  runOrThrowIO,
  fromEitherSTM,
  runOrThrowIOAndTraceUnit,
  runOrThrowIOAndTrace,
  logAndThrowIO,
  handleAndLogError,
  shouldAbortOnPanic,
  hasAbortOnPanicEnv,
  runOrThrowApp,
  runOrThrowAppUnit,
  dbSyncNodeError,
  throwAppError,
) where

import Cardano.BM.Trace (Trace, logError)
import qualified Cardano.Chain.UTxO as Byron
import Cardano.DbSync.AppT (App)
import Cardano.DbSync.Error.Types (SyncInvariant (..), SyncNodeError (..))
import Cardano.Prelude
import Control.Monad.Trans.Except.Extra (left)
import Data.Text (pack)
import qualified Data.Text as Text
import System.Environment (lookupEnv)
import System.Posix.Process (exitImmediately)

runOrThrowApp :: forall e a. (Exception e) => Trace IO Text -> App (Either e a) -> App a
runOrThrowApp tracer ioEither = do
  et <- ioEither
  case et of
    Left err -> do
      liftIO $ logError tracer $ pack $ show err
      throwIO err
    Right a -> pure a

-- | A version of `runOrThrowApp` that returns `()` instead of `a`.
runOrThrowAppUnit :: forall e. (Exception e) => Trace IO Text -> App (Either e ()) -> App ()
runOrThrowAppUnit = runOrThrowApp

dbSyncNodeError :: Trace IO Text -> SyncNodeError -> App (Either SyncNodeError ())
dbSyncNodeError tracer err = do
  liftIO $ logError tracer (pack $ show err)
  pure $ Left err

throwAppError :: Trace IO Text -> SyncNodeError -> App ()
throwAppError tracer err = do
  liftIO $ logError tracer (pack $ show err)
  throwIO err

dbSyncInvariant :: (Monad m) => Text -> SyncInvariant -> ExceptT SyncNodeError m a
dbSyncInvariant loc = left . SNErrInvariant loc

fromEitherSTM :: (Exception e) => Either e a -> STM a
fromEitherSTM = either throwSTM return

runOrThrowIOAndTraceUnit :: forall e m. (MonadIO m) => (Exception e) => Trace m Text -> m (Either e ()) -> m ()
runOrThrowIOAndTraceUnit = runOrThrowIOAndTrace

runOrThrowIOAndTrace :: forall e a m. (MonadIO m) => (Exception e) => Trace m Text -> m (Either e a) -> m a
runOrThrowIOAndTrace tracer ioEither = do
  et <- ioEither
  case et of
    Left err -> do
      logError tracer $ show err
      throwIO err
    Right a -> pure a

runOrThrowIO :: forall e a m. (MonadIO m) => (Exception e) => m (Either e a) -> m a
runOrThrowIO ioEither = do
  et <- ioEither
  case et of
    Left err -> throwIO err
    Right a -> pure a

logAndThrowIO :: Trace IO Text -> SyncNodeError -> IO ()
logAndThrowIO tracer err = do
  logError tracer $ show err
  throwIO err

handleAndLogError ::
  forall a m.
  (MonadError SyncNodeError m, MonadIO m) =>
  Trace IO Text ->
  Either SyncNodeError a ->
  m a
handleAndLogError tracer result = case result of
  Left err -> do
    liftIO $ logError tracer $ Text.pack $ show err
    throwError err
  Right val -> pure val

-- The network code catches all execptions and retries them, even exceptions generated by the
-- 'error' or 'panic' function. To actually force the termination of 'db-sync' we therefore
-- need a custom panic function that is guaranteed to abort when we want it to.
-- However, we may not want to abort in production, so we make it optional by use of an
-- environment variable.
shouldAbortOnPanic :: Text -> IO ()
shouldAbortOnPanic msg = do
  whenM hasAbortOnPanicEnv $ do
    threadDelay 100000 -- 0.1 seconds
    mapM_ putStrLn ["DbSyncAbortOnPanic: ", msg]
    exitImmediately (ExitFailure 1)

hasAbortOnPanicEnv :: IO Bool
hasAbortOnPanicEnv = isJust <$> lookupEnv "DbSyncAbortOnPanic"

annotateInvariantTx :: Byron.Tx -> SyncInvariant -> SyncInvariant
annotateInvariantTx tx ei =
  case ei of
    EInvInOut inval outval -> EInvTxInOut tx inval outval
    _other -> ei
